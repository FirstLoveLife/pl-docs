# 关于语法

## 引言

　　有人说语法很重要。这点我实际上一直不否认，但一定程度上（除了[这篇文章](what-is-syntax.md)）并没有表达过一个整体上为什么有意无意地在语言设计和分析中避免“优化语法设计”这样的工作的理由，所以有必要概括一下观点。

　　因为上下文是编程语言，所以“语法”指的是 syntax ——这在自然语言中是“句法”，但编程语言不存在严格对应的“句”的概念；自然语言意义上的语法则是更一般的文法(grammar) 。

## 重要

　　很多人同意，记号(notation) [影响思想的表达](https://github.com/hypotext/notation)。这种影响可能是积极的，也可能是消极的：合适的记号使表达的成本更低而更具有可行性；糟糕的记号可能会对交流制造意想不到的门槛，并歪曲表达的原意，进而限制思想的可行性。

　　语法提供作为系统化的、有规律可循的记号系统的基本规则。除了少数强调直观而非普遍性的更适合图形等非文字和非符号化表达的场合，语法对人工设计的记号系统的作用是毋庸置疑的：它很重要。考虑到使用频率，语法就像呼吸一样。也因此我不能忍受复杂到在日常使用时需要刻意注意的构造，并且有意远离不得不使用这些构造的场合。要是一个人时不时[潮式呼吸(en-US)](https://en.wikipedia.org/wiki/Cheyne–Stokes_respiration) 的话，那么大概是快要挂了。

## 变化

　　另一方面，既然众口难调是现实，通用目的语言中呈现的最终的语法就应该允许让用户定制。这更容易使之被排除出语义规则之外单独设计——如 Racket 这样的基于传统 Lisp 的 read macro 基础上扩展出来的方案。

　　这样的现实需求也体现语言设计中分离语法和语义规则（而不是铁板一块的混沌文法）的普遍必要性——考虑到应对需求而变更不成熟的语法设计的代价仍然不会小到哪去（未必困难，但对会设计并更感兴趣使用语义解决实际问题的语言设计者来说，不用普遍规则概括的细节几乎总是烦的），只有极端不在意语法的“一次性”的小规模[领域特定语言](https://zh.wikipedia.org/zh-cn/领域特定语言)设计中，才可能漠视这种模式而不造成麻烦。

## 复杂

　　需要刻意注意的构造通常来自语法规则的复杂性。这种复杂性是抽象的，但并不是很难体现。对设计者以外的用户，最主要负担这种复杂性的场合体现在语法分析(parse) 上——不论是对人还是对机器的实现而言。

　　解析复杂的语法需要更多的上下文切换(context switch) 。用“上下文切换”这种特定机器实现气息浓厚的说法，是因为这不仅是人脑应对复杂性的比喻，而是普遍事实。就是抽象的机器实现，在[抽象机(abstract machine)](http://www.ccs.neu.edu/home/matthias/redex-workshop/wed-aft.html) 操作语义的底层这恰恰是带来无法避免的开销的本质的麻烦之一——如函数调用和 `eval` 操作的 E(environment) 这样的上下文——虽然这仅仅是操作语义（元语言）中的真正的 context（所谓 hole ）的一个实例。

　　当然，机器的实现跟人脑相比通常并不计较运行时的开销，但实际情况当然远远不止例子中的规模，而且多余的开销处处存在。就算机器快到运行时无所谓多余的开销，设计、实现和测试语法分析器(parser) 的普遍代价也不是零。

　　更深层次的复杂来自语法规则自身。过于复杂和特设(ad-hoc) 的规则缺乏泛用性，而使记忆语法规则的效用下降；这反过来削弱了语法的重要性，也制造了冗余：反正记不清楚，为什么去记“不常用”的语法呢？为什么不在遇到“不常用”的语法的时候去查询语法规则呢？这里的问题是，划分“常用”或者“不常用”的语法子集的策略几乎无法避免导致用户体验的下降。实用场景中，判断“常用”和“不常用”的代价无论如何都很难是零，不论是读还是写，都很容易被打断现有的思路来对这些底层的问题进行“中断处理”。这种“优先级反转”损害了用户的普遍利益。早知这样，为什么不考虑简化语法呢？

　　一些设计者漠视语法设计中可能具有的用户体验问题的设计带来的问题，原因可能是：

* 无知：欠缺对使用场景和目的敏感性，也不知道普遍的做法的外延。
* 懒惰：逃避分析需求和方案的合理性。
* 跟风：无原则地认为遵循现有的设计是保险的。
* 盲目：因为种种认知偏差，认为这样的设计在绝对意义上代价不高，用户“应该”乐于接受。

　　有的语法设计，在特定的场景下可能是相对合理的，但在一般意义上具有不必要的复杂。这部分的复杂可能被作为习惯而遗留到其它衍生设计中，而先前的合理性不能发挥作用。这使复杂设计的负面作用更加明显，并且可能会有一些意想不到的副作用。

　　作为日常工具的语法需要有效，因此解析技术的复杂在工程上只能是妥协，而非适合通过复杂度来展现意义的话题。一旦复杂，那么已经说明某种失败。而以实现技术本身以外的进展在更大的背景（例如某个具体项目，或者作为评判某个语言设计话题的依据）下用复杂的分析器炫技，其理由比上面的分析或许更简单——多是无知（不知轻重）或无耻（有意搅混水）至少其一的行径。

### 关于上下文的例子

　　举例来说，解析 `1 + 2 + 3` 这样的表达式，不管按哪个方向扫描输入的字符，遇到不同的记号(token) 时总需要至少切换一次上下文并记忆状态；相比之下，用 `(+ 1 2 3)` 这样的同义表达式，在减小记号数量同时减少上下文切换数量上的效果高下立判。

### 关于历史遗留问题的例子

　　C 语言的中缀声明符(declarator) 语法，和二元操作符(operator) 表达式的中缀语法类似，在技术上都具有减小源代码长度的优势。而要保证能正确表达和分析这样的语法实际上是相当复杂的：

* 语言规范中的形式语法具有两套略相关但技术上没法合理去重的形式：声明符和抽象声明符。
* 几乎只能根据语言规范中的形式文法匹配而没有能够保证正确性的变通优化的替代规则。
	* 对机器来讲这似乎不是太大的问题，但对人来讲这是灾难性的：这些语法规则几乎不会被用户记住，于是在声明复杂到无法用直觉判定时，用户只能借助于看似靠谱但其实不能保证万全的“经验规则”，例如[通称为“右左法则”的经验分析方法](https://docs.microsoft.com/en-us/cpp/c-language/interpreting-more-complex-declarators?view=vs-2019)。
		* 这不能正确分析被声明的标识符不明确的情形，例如函数声明的声明符中同时具有作为参数名标识符时。
		* 人类读者产生可分析的错觉的主要原因是，看到一个复杂的 C 声明时，读者倾向于首先认知这是单独的一个声明，且能根据已知的上下文语义信息确定哪个标识符是当前尚未声明的。
		* 但在严格意义上，上述简化假设是不能保证的：一个声明可能包含多个声明符；一个声明符中可能具有多个标识符，且不能在仅知声明而不提供上下文信息时，通过“右左法则”准确判定哪个标识符应被声明。
		* 对此的一个变通是，如有可能，避免使用复杂的声明，而使用 `typedef` 等同义形式代替。然而，用户实际上并没法保证这一点，在权威来源中也可能存在足够复杂形式的声明（例如， ISO C 的 库函数 `signal` 的原型）。这也是上述经验规则的流行的一个原因。
* 讽刺的是，显然今天绝大多数的 C 语言用户已经不再利用这里的技术优势。
	* 例如，几乎所有代码规范都会约定，声明符的记号之间应插入空白符（以提升可读性）。
* 一个历史副作用是，声明符中的 `ptr-declarator`（也就是包含参与到决定类型名中的 `*` 的声明符）无谓地制造了代码风格的分歧：到底是 `T* p`、`T *p` 还是 `T * p` ？
	* 从一个 `ptr-declarator` 对应一个被声明的标识符，而一个声明可包含多个 `ptr-declarator` （如 `T *p, *q, r;`）的角度看，似乎 `T* p` 是合理的。
		* 但事实上这不适用于函数的形式参数的声明。若要正确反映此处声明的语义，在函数参数列表中应该使用 `T* p` 。若已经在其它场合使用了 `T* p` 以外的声明方式，为避免损害一致性，在函数参数声明中对应使用 `T *p` 的风格仍然很常见。
		* 这在早期的 K&R 声明语法中不是问题，因为早期的函数声明根本不支持在参数列表内部声明参数类型的语法。然而，新的语法是 ANSI C 鼓励的原型声明方式，也是现在主流的用法。如 C++ 等借用 C 语言的设计的语法，即便继承了声明符语法（以及这里风格分歧）的传统，也不支持 K&R C 风格的声明，因此必须面对这个问题。
	* 相比之下，统一为 `T* p` 看起来是个更务实和容易在不同用户之间贯彻一致性的做法。分离 `T*` 这样的类型名一般具有更好的可读性，尤其对兼容这样的语法但针对类型名的操作可能更频繁的 C++ 这样的语言来讲。不过由于语言仍然支持 `T *p, *q, r;` 的声明，这还是一定程度上依赖自觉。
	* 除此之外，实际上还有 `*` 和其它行声明对齐的风格。不过这种风格是特定目的下的局部风格，一般用意比较容易辨认而不至于引起误会，所以问题相对较小。
* 这样的设计遗留到了其它语言中。
	* 最广为人知的例子可能是 C++ 。进一步地，C++ 扩充了声明符中的 `ptr-declarator` 的记号 `*` ，允许 `&` 和 `&&` （单从这里的设计体现一致性倒是无可厚非）。类似的扩展还有 C++/CLI 的 `^` 。
	* 即便 Java 没有 `ptr-declarator` 的对应物，在数组的声明语法中还是采用了类似的做法。
	* C# 相比 Java 放弃了中缀的写法，即便 C# 重新引入了指针而需要有 `*` ：声明的语义上保证了 `*` 和类型名前缀的结合，而不支持一个前缀对应多个 `ptr-declarator` 。如需在同一个声明中引入多个标识符的声明，则需要重复 `*` 。这也基本消除了上述代码风格的争议，但在对习惯与之不兼容的 C/C++ 语言语法的用户来讲，仍有误用风险。

　　不限于中缀风格的声明符语法，一般的中缀操作符的表达式语法也带来了一些限制。除了和中缀声明符语法（以及刻意引入 `++i` 和 `i++` 这样微妙的设计）同样损失了原始的节约源代码长度的技术优势外，中缀操作作为表达式语法还限制了表达能力，并因为复杂的优先级和结合性的语法规则的特征，制造用户记忆上的负担：

* 二元操作的语法不能直接自然过渡到函数调用，不同的语法导致为了看起来普遍自然，可能需要添加“操作符重载”的设计。如果一开始就没有特设的二元操作，那么根本不需要有这些复杂性同时仍能不损失相同语法代表的操作的普遍性。
* 四则运算以及 `%` 或许容易被多数初学者接受和掌握，但大部分即便在工业界“熟练”掌握 C 语言的用户并不足以让业界信任准确掌握了 `<<` 以及 `&` 等操作符和这些运算混用的情形，以至于甚至实现都需要警告加上括号。
* 类似 C 语言这样具有“丰富”的（二元甚至更多元）操作符的现有设计似乎使某些设计者产生了对用户接受扩充中缀语法的盲目乐观，乃至认为中等教育程度的用户应当能像接受四则运算一样容易接受各种不同的中缀语法。
	* 然而“定义新运算”的语法实践实际上普遍不属于学历教育中的必修内容（尽管可能出现在所谓“奥林匹克数学”的教学中），所以至少对初学者，门槛是普遍存在的。
	* 即便是对有经验的用户，不同语言之间可能存在的微妙的差异带来的成本也不是零，唯一能普遍可行的方法似乎就是忘记特设的优先级和结合性规则，不确定时就加上括号——然而这样为什么不直接用函数代替特设语法的操作符呢？

## 意义

　　语法设计的复杂，除了导致上述的复杂处理的表面问题外，还隐藏了更一般的麻烦问题：损失普遍性，并妨碍抽象的目的。

### 计算目的

　　对（因为不方便使用而）不适用 [AOT 编译(en-US)](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) 的场合——包括人脑——解析语法的工作构成了求值算法(evaluation algorithm) 的算法复杂性的基础，也构成了计算性上的(computational) ——即为了通过操作语义规则得到计算结果的——需要克服的复杂性的基础。因此复杂的语法和语义一样会直接影响实现计算目的的效率。如果解析语法不是直觉上特别有目的的行为，语法不应该承担比语义更显著的角色。

　　一个语法上起到重要作用的构造的例子是[结合律](https://zh.wikipedia.org/zh-cn/结合律)。结合律用中缀风格的语法来表达时显得简洁易记，但使用前缀或后缀的写法就比较晦涩了。这说明中缀语法的优越吗？不，普遍来看恰恰相反，一般的计算中非二元操作远远多于（主要是作为某些构造性实现的）二元操作，因此结合律实际上并不应具有计算上的普遍作用。习惯性滥用结合律是一个“以辞害意”的例子。

### 本质问题

　　强调并不自觉依赖结合律这样的语法风格，在语法以外的一个直接原因是“二元操作中心主义”。这体现在二元操作的原生特殊支持——而扩展二元操作往往用[fold(en-US)](https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29)实现。但是，若要反方向归纳到二元以下的操作上，又需要有特殊的规则。这和 Lisp 风格用 `(+)` 、 `(+ 1)` 、 `(+ 1 1)` ……这样的序列通吃任意有限参数个数的操作而归纳出一致性相比，显得并不自然。

　　当然，以二元操作中心的方法论用于抽象目的上并非全然是无效的。得益于[数学归纳法](https://zh.wikipedia.org/zh-cn/数学归纳法)和[递归](https://zh.wikipedia.org/zh-cn/递归)的表达形式，像 [cons pair](https://en.wikipedia.org/wiki/Cons) 这样的还原主义方法就体现出了单一的二元操作(cons) 的简洁而普遍的威力。

　　但是，体现这种适用性的目的是*建模(modeling)* ——为了得到抽象的描述和理解对象本身的构造。一旦目的改为通过变换不同粒度的对象以解决一般的问题——*计算(computing)* ，其最明显的劣势就体现来了：直接使用二元操作解构运算的步骤来替代计算上的操作，会有复杂度上的困难。造成这种困难的原因是，要解决的问题通常并不在乎二元操作这种具体的实现细节，而二元操作隐含的归纳法本质依赖的局域性可能就只能作为可选的实现细节才不至于阻碍问题的解决。实际是否形成阻碍，取决于算法是否仅依赖局域特性。例如，当对一个序列(sequence) 进行搜索时，元素访问操作是局域的，而比较操作是不限制局域性的，因此使用 cons pair 这样的方式来表达序列的构造并不阻碍只依赖局域操作的最基本的顺序迭代算法；但这样的构造并不能利用超出相邻元素的局域的性质——当这个序列全局有序时，使用 cons pair 的构造无法利用全局性而不能直接支持[降低计算复杂度的有效算法](https://zh.wikipedia.org/zh-cn/二分搜索算法)。再如，cons pair 的实现方式蕴含了序列中非预期存在的构造顺序这一细节，而暴露了构造、访问和析构操作可能的和顺序相关的[副作用](https://zh.wikipedia.org/zh-cn/函数副作用)，使结构上的实现细节（非预期地）泄漏到普遍行为上，阻碍[信息隐藏(en-US)](https://en.wikipedia.org/wiki/Information_hiding) 和抽象目的的准确表达。

　　另一个次要的困难是，表达本身在计算上的冗余——罗嗦。有时候，这种罗嗦还可能“传染”到使用这些表达的问题的解中，使解的形式并不够具有预期的良好性质。要使解能符合原始目的，还需要一个附加的变换把解的形式修改回看上去更“正常”的形式。实际上，这时候被直接解的问题并不是原始问题。通过变换问题的形式使问题可解是个很实用的重要思路，但是在问题本来就并非难以解决时，这种多此一举就是一种过度设计，显然是有害的。

　　上述问题共同导致许多常用的抽象脱离使用二元操作构造表示的模型而存在独立的意义。不少时候，通过二元操作或其它还原论方法构造的模型仅仅起到模型论意义上的作用——例如，大多数时候人们不使用[集合论编码](https://zh.wikipedia.org/zh-cn/自然数的集合论定义)来表示自然数，即便是不使用加法之类套用模型会有算法复杂度问题的场合。

### 其它妨碍

　　在具体使用中，过度依赖二元操作代替更直接自然的形式还会以更复杂和看似偶然的方式嵌入到整体设计中，影响语言用户对问题和解决问题的方法的理解。这些影响的广泛性和深刻性可能并不小于上面的本质问题造成的负面影响。这些影响至少包括：

* 这种习惯倾向在语言设计中引入特设的(ad-hoc) 欠缺可扩展性的特性。其中，最直接的典型是[操作符重载(en-US)](https://en.wikipedia.org/wiki/Operator_overloading) 。
	* 因为语法上有限的操作符（通常其优先级和结合性还被写死了）通常有受限的内置的语义，不足以表示一些近似的语法形式，保留语法而替换具体语义的“重载”被发明以解决这样的问题。
	* 作为一个直接结果，这使语言的语义规则更加复杂。
		* 和通用的其它设计结合，这直接制造了更多需要解决的问题（例如，如何解析操作符找到非内建处理操作符的逻辑，使之能和词法作用域(lexical scoping) 、名称解析(name resolution) 等一般机制相容）。
		* 当然，无视复杂性的代价，这确实是可解决的，而且大部分复杂性普通用户经过训练后可以无视——所以也的确被作为 C++ 等一些现实语言的特性和“优点”。
	* 但是反过来，为什么不直接使操作符和“函数”一样共享语法而根本不需要引入这些特设的规则呢？
		* 即便非要适应特定领域用户对语法习惯，也完全可以局部地作为[语法糖](https://zh.wikipedia.org/zh-cn/%E8%AF%AD%E6%B3%95%E7%B3%96)来设计，而不需要引入成套的复杂规则。
		* 现实中，不得已引入特设的复杂的规则，一个可能的原因是在此之前因为语言欠缺通用的语法扩展能力（如[卫生宏(en-US)](https://en.wikipedia.org/wiki/Hygienic_macro)）而无法可靠地把这样的特性作为语法糖，不过这就是另一个话题了。
	* 注意操作符重载是一种[特设多态(en-US)](https://en.wikipedia.org/wiki/Ad_hoc_polymorphism)，因此也自然具有特设多态带来的实用性问题，例如滥用（过度依赖领域知识）导致难以理解。不过这和语言的语法设计没有直接关系（因为造成的问题多少取决于用户如何使用这项特性），应与以上问题区分。
* 传统数学教育不够区分操作符关联的[操作顺序(en-US)](https://en.wikipedia.org/wiki/Order_of_operations)而使用户容易存在一些对计算本质上认识偏差。从经验上看，这种实际偏差被某些语言设计的问题放大了，且已经造成了用户学习和使用的困难，乃至因此在产品中制造了更多的缺陷。
	* 因为传统数学中表达计算的系统本质上是[纯函数式](https://en.wikipedia.org/wiki/Purely_functional_programming)的，在子表达式中使用操作数进行计算的不同局部顺序并不会影响表达式整体的计算结果，所以新手往往不会注意到迁移到更有表达力的可能有[副作用(en-US)](https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29) 的系统中，忽略顺序导致的后果和导致这些后果的直接原因。继续这种思路进行语言的教学，会使用户容易陷入误区，事半功倍。
		* 用户被迫使用和数学教育过程中习得的相当不同的思维理解编程系统才能使编写的程序大体符合预期，而错失探究不同语言之间在数学上（例如，[重写系统](https://en.wikipedia.org/wiki/Rewrite_system)的意义下）的存在的一些普遍联系的机会。
		* 用户同时错失对[求值策略(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy) 进行认识的机会，而进一步妨碍对计算的本质特征和典型的语言如何实现计算的一般机制的理解。
	* 因为对顺序问题理解上的含糊，使用表达式求值可能有副作用的语言，用户往往有更大的机会犯错，并且甚至在试图解释时继续犯错而自以为是地认为理解了。一个经典的例子是 C 语言的 `printf("%d %d %d", i++, i++, i++)` 这类存在[未定义行为](https://zh.wikipedia.org/wiki/未定义行为)的表达式求值的解释。
		* 抛开表述未定义行为的语言规则对表达式的求值顺序(order of evaluation) 的概念具有的依赖，混淆从左往右的语法分析顺序（同时应该也是大多数用户会习惯的“自然”的阅读顺序）和求值顺序甚至附会到某些实现的[调用约定](https://zh.wikipedia.org/wiki/调用约定)中作为函数参数的子表达式求值结果的传递顺序这**三种不同顺序**的问题，使用户对程序语义（而不是行为）的理解可能南辕北辙。
		* 未定义行为本身的性质使用户进一步原则上不可能推测出程序能具有的“正确”的可预期行为。
	* 即便抛开顺序本身的含义，使用 [PEMDAS(en-US)](https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics) 这样的助记符灌输个别的教条形成的刻板印象也容易使用户适应新的优先级和结合律等规则更加困难。最直接的，用户需要一定程度上在 PEMDAS 以外的操作符的表达式付出记忆求值规则的成本。
	* **中缀中心主义的风格以一种不容易被注意到的方式大大加深了类似的潜意识性的影响**，使用户更难判断语言设计的合理性。虽然因为不少语言会以支持大量的操作符（以及对应表达式的特设的求值规则）来体现“功能丰富”，这实际上因为规则上多出来的上述记忆成本等问题而放大了这类设计的局限；但种种原因下，某些语言设计者和用户仍然陷入了斯德哥尔摩综合症的怪圈（认为中缀是“大众”意义上更合理的，全然不知晓或理会因果上的先来后到）。
	* 同时，没受到这些思维定势和怪圈影响的用户通常并不怎么关心这里的问题，或者认为问题不大，结果导致市面上的语言更倾向于不在乎这些问题的设计。久而久之，工程选型的范围也受到限制，在这方面上就整体“劣币驱逐良币”了。

### 一转攻势

　　着力于在两个现有数学体系之间建立联系（通过[态射](https://zh.wikipedia.org/wiki/态射)）的[范畴论](https://zh.wikipedia.org/zh-cn/范畴论)本来并没有太多的槽点，不过其中一些不良语法习惯被某些语言奉为“函数式”正统设计以至于把一些用户迷得神魂颠倒就颇有些奇怪了。

　　讽刺的是，在这个背景下的最基础的[复合](https://ncatlab.org/nlab/show/composition)，传统语法也有[歧义](https://ncatlab.org/nlab/show/composition#Notation)，以至于要强调所谓的 diagrammic order 。注意作为结合律的适用的典例，复合操作具有上面提及的所有问题。强调 diagram 这种先天被局域作用限制的语法已经在一定程度上误导了局部结构的在一般问题的解中所占的比重，乃至歪曲了表达解时本应注意到的抽象甚至目的。

## 解决

　　避免麻烦的语法和相关问题的大部分套路并不难：

* 除非必要，避免新造 DSL 。
  * 使用成熟的设计。
  * 使用通用目的语言构造 DSL ，而不是从头造轮子。
* 避免没有明确目的的中缀语法等过度依赖局部结构的设计。
  * 尤其避免设计生造的新的中缀语法。
  * 使用类似 `x . y . z` 到 `. x y z` 这样的变换消除一般情形中对结合律等局部特异性质的不当依赖。

　　不过，不擅于独立思考以及观念上先入为主的偏见容易导致难以实践本应简单的套路。这可能是相当难以纠正的。原因的一部分可以归因于理解上的困难，这来自经验和想象力的匮乏。

　　例如，就二元操作语法，有观点认为：函数调用表达式中，作为操作符的函数和操作数(operand) 的语法组合仍然是中缀的；即 `f x y` 实际上是 `f call x y` 或者更明显的 `(f) call (x y)` ，其中 `call` 是原本隐含的中缀操作符。这从实用上看似自然，实际却隐含了使用关于“调用”的求值策略的并不见得那么自然的前提：操作符和操作数作为表达式的求值保持相对独立，例如 [WHNF(en-US)](https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form) 。作为后果，这种刻板印象排除了一些非决定性的其它优化求值策略，如允许在求值前对操作符内部结构进行（可能和操作数表达式有关联的）分析的[完全 β 规约(en-US)](https://en.wikipedia.org/wiki/Evaluation_strategy#Full_β-reduction)，而成为“以辞害意”限制可行表达的一个例子。

